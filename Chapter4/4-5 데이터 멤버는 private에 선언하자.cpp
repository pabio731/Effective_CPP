/*
	데이터 멤버를 private에 선언해야 하는 이유
	1. 문법적 일관성.
	   모두private이면  사용자가 객체에서 접근할 수 있는 것은 멤버 함수일 것이다.
	   어떤 클래스의 공개 인터페이스에 있는 것이 모두 함수라면 괄호를 붙여야 하는지에 대한
	   고민이 없을 것.

	2. 데이터 멤버에 대한 훨씬 정교한 제어 가능
	   privae에 데이터 멤버를 선언한다면 접근불가, 읽기 전용, 읽기 쓰기 접근을
	   우리가 직접 구현할 수 있다. 심지어 쓰기 전용까지도
*/

class AccessLevels
{
private:
	int iNoAccess;		// 접근 불가
	int iReadOnly;		// 읽기 전용 접근
	int iReadWrite;		// 읽기 쓰기 접근
	int iWriteOnly;		// 쓰기 전용 접근
public:
	//...
	int GetReadOnly() const { return iReadOnly; }
	void SetReadWrite(int iValue) { iReadWrite = iValue; }
	int GetReadWrite() const { return iReadWrite; }
	void SetWriteOnly(int iValue) { iWriteOnly = iValue; }
};

/*
	위와 같은 접근은 어떤 식으로든 노출시키면 안되는 데이터 멤버들이 꽤 많기 때문에
	나름대로의 중요성을 갖고 있다.

	3. 캡슐화
	   사실 가장 중요할 수 있다. 함수를 통해서만 데이터 멤버에 접근이 가능하다면
	   데이터 멤버를 나중에 계산식으로 대체할 수도 있고, 사용자는 이 클래스를 넘보지 못한다.

	4. 데이터 멤버를 함수 인터페이스 뒤에 감추게 되면 구현상의 융통성을 전부 누릴 수 있다.
	   데이터 멤버를 읽거나 쓸 때 다른 객체에 알림메시지를 보낸다든지. 불변속성 및 사전조건,
	   사후조건을 검증한다든지, 스레딩 활경에서 동기화를 건다든지 하는 일등...

	   데이터 멤버를 숨기면 불변 속성을 항상 유지하는 데 절대로 소홀해질 수 없게된다.
	   불변속성을 보여줄 수 있는 통로가 멤버 함수밖에 없기 때문에...

	protected 데이터 멤버도 앞서 말한 사정과 거의 같다.
	어떤 것이 바뀌면 깨질 가능성을 가진 코드가 늘어날 때 캡슐화의 정도는 그에 반비례해서 작아진다.
	즉 데이터 멤버가 바뀐다면(제거된다면) 깨질 수 있는 코드의 양에 반비례해서 그 데이터 멤버는 캡슐화 정도가 감소한다.

	public에 있는 데이터 멤버를 제거한다면 많은 코드들이 망가질 것인데...
	protectd의 데이터 멤버도 많은 파생클래스들이 망가질 것. 따라서 그놈이 그놈이다.

*/