#  Effective C++
쥬신 게임 클라이언트 프로그래밍 학원을 다니며 Effective C++을 읽고 정리한 내용입니다.

---

# 정리 기간 2023년 11월16일 ~
목표는 하루 2개의 챕터씩 나아가는 것!

---


## 현재 진행
## Chapter 1 : C++의 법을 따르자

- 1-1 c++은 언어들의 연합체

- 1-2 define을 쓰기전에 const, enum, inline을 먼저 생각하자
  
- 1-3 const를 적극 사용하자
  
- 1-4 객체를 반드시 초기화하자

## Chapter 2 : 생성자와 소멸자, 대입연산자
  
- 2-1 C++이 은근슬쩍 만들어 호출하는 함수들

- 2-2 컴파일러가 만들어낸 함수가 필요없으면 사용을 금지해버리자

- 2-3 다형성을 가진 기본 클래스의 소멸자는 가상 소멸자로

- 2-4 예외가 소멸자를 떠나지 못하도록하자

- 2-5 객체 생성 및 소멸 과정 중에는 가상 함수를 호출하지 말자

- 2-6 대입 연산자는 *this의 참조자를 반환하게 하자

- 2-7 대입 연산자 오버로딩에서는 자기대입에 대한 처리를 꼭 하자

- 2-8 객체의 모든 부분을 빠짐없이 복사하자

## Chapter 3 : 자원 관리

- 3-1 자원 관리 객체를 만들어 쓰자

- 3-2 자원 관리 클래스의 복사 동작에 대해 생각하자

- 3-3 자원 관리 클래스에서 관리되는 자원은 접근 가능하도록 하자

- 3-4 new,delete를 사용할 때는 형태를 반드시 맞추자

- 3-5 new로 생성한 객체를 스마트 포인터에 저장하는 코드는 별도의 문장으로 

## Chapter 4 : 설계 및 선언

- 4-1 인터페이스 설계는 제대로 쓰기에 쉽게, 엉터리로 쓰기엔 어렵게 만들자

- 4-2 클래스 설계는 타입 설계와 똑같이 취급하자

- 4-3 상수 객체 참조자에 의한 전달 방식을 쓰자

- 4-4 함수에서 객체를 반환해야 할 경우 참조자를 반환하려하지 말자

- 4-5 데이터 멤버는 private에 선언하자

- 4-6 멤버 함수보다 비멤버 비프렌드 함수와 더 가까워지자

- 4-7 타입 변환이 모든 매개변수에 적용되어야 한다면 비멤버 함수를 선언하자

- 4-8 예외를 던지지 않는 swap에 대한 지원도 생각해보자

## Chapter 5 : 구현

- 5-1 변수 정의는 늦출 수 있는 데까지 늦추자

- 5-2 캐스팅은 절약하자

- 5-3 내부에서 사용하는 객체에 대한 핸들을 반환하는 코드는 되도록 피하자

- 5-4 예외 안정성을 확보하기 위해 싸우자

- 5-5 인라인 함수는 잘 이해해두자

- 5-6 파일 사아의 컴파일 의존성을 최대한 줄이자

## Chapter 6 : 상속과 객체 지향 설계

- 6-1 public 상속 모형은 is-a 를 따르도록하자

- 6-2 상속된 이름을 숨기는 일은 피하자

- 6-3 구현 상속과 인터페이스 상속의 차이를 제대로 알자

- 6-4 가상 함수 대신 쓸 것들도 생각해주자

- 6-5 상속받은 비가상 함수를 파생 클래스애서 재정의하는 것은 금물

- 6-6 어떤 함수에 대해서도 상속받은 기본 매개변수 값은 재정의하지 말자

- 6-7 has-a 혹은 is-implemented-in-terms-of를 모형화 할때는 객체 합성을 사용하자

- 6-8 private 상속은 심사숙고해서 쓰자

- 6-9 다중 상속은 심사숙고해서 쓰자

## Chapter 7 : 템플릿과 일반화 프로그래밍

- 7-1 템플릿 프로그래밍은 암시적 인터페이스와 컴파일 타임 다형성부터

## 추가로 알고 있어야 할 부분과 피드백
- auto_ptr은 더이상 쓰이지 않는 스마트 포인터이다.
- 업캐스팅 한 포인터와 파생 클래스 포인터가 같은 파생 클래스 객체를 가리켜도 주소가 달라질 수 있는 것은 아주 과거의 이야기 일 수 있다. 
- pImpl 패턴 같은 것은 이제 필요 없다고 봐도 무방하다. 컴파일 속도가 과거에 비해 빨라져서...
- is-a 관계에 대해 알고 있었지만 정확히 사용하지 않았던 것 같음. 이에 대해 좀 더 생각하고, 가상함수로 할 것과, 순수 가상 함수로 할 것 등등 좀 더 신중하게 설계하자.
