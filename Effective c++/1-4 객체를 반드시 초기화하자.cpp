#include<iostream>

/*
	c++에서는 어떤 경우는 선언만 해도 알아서 초기화 되지만(전역 변수) 어떤 경우는 되지 않는다. 
	이는 클래스의 멤버 변수도 마찬가지. 초기화 되지 않은 값이 읽히면 미정의 동작이 되거나 상황에 따라서 
	프로그램이 서버린다. 
	따라서 모든 객체를 항상 초기화 해놓는 습관이 중요하다. 일단 변수는 일반적으로 아는 방법대로 초기화 해주면 되지만
	이제 클래스의 생성자에 대해서 생각해 봐야한다.
	절대! 대입과 초기화를 헷갈려서는 안된다.
*/
#include<list>
class PhoneNumber{};
class ABEntry
{
private:
	std::string sTheName;
	std::string sTheAddress;
	std::list<PhoneNumber> ThePhone;
	int NumTimesConsulted;
public:
	ABEntry(const std::string& sName, const std::string& sAddress, const std::list<PhoneNumber>& phone);
};
ABEntry::ABEntry(const std::string& sName, const std::string& sAddress, const std::list<PhoneNumber>& phone)
{
	sTheName = sName;
	sTheAddress = sAddress;
	ThePhone = phone;
	NumTimesConsulted = 0;
}					//이것은 대입이지 초기화가 아니다!!!!

/*
	C++ 규칙상어떤 객체든 그 객체의 데이터 멤버는 생성자의 본문이 실행되기 전에 초기화되어야 한다고 명시되어 있다.
	따라서 위 생성자는 본문에 들어기전에 초기화 실패. 정확히는 ABRntry 생성자에 진입하기 전에 각 데이터 멤버의
	기본 생성자가 호출되었음.
	위 문제를 해결하기 위해서 대입이 아닌 초기화 리스트를 사용하자*/
ABEntry::ABEntry(const std::string& sName, const std::string& sAddress, const std::list<PhoneNumber>& phone)
	: sTheName(sName), sTheAddress(sAddress), ThePhone(phone) {}
/* 
	위와 같이 초기화 리스트에 들어가는 각 데이터 멤버의 인자는 각각의 생성자 인자로 쓰인다.
	대입방식 -> 기본 생성자 호출 후, 복사 대입 연산자 실행
	초기화 방식 -> 기본 생성자 호출 때 복사 생성자 한번 호출
	기본 제공 타입은 비용의 차이가 거의 없지만 그래도 초기화 리스트에 모두 넣어주는 것이 좋다. 인자로
	줄 것이 없더라도 초기화 리스트 사용할 것.

	특히 상수이거나 참조자로 되어있는 데이터 멤버인 경우 반드시 초기화 되어야 한다. 
	왜냐면 위 두 가지는 대입이 불가능하기 때문.
	만약 클래스의 생성자가 여러개고, 각 생성자가 초기화 리스트르 주렁주렁 달고 있는 것이 별로라 생각이 든다면
	대입으로 초기화 가능한 멤버들을 별도의 함수에서 대입하게 만들고, 모든 생성자가 해당 함수를 불러오게 하는 것도
	나쁘진 않다. 특히, 파일에서 초기값으 읽어온다던지, 데이터베이스에서 찾아오는 경우 더 유용.

	객체를 구성하는 데이터의 초기화 순서도 중요한데, 
	1. 기본 클래스가 파생 클래스보다 먼저 초기화. 
	2. 클래스 데이터 멤버는 선언된 순서대로 초기화된다. ->초기화 리스트 순서 달라도 선언순으로 초기화

	다음으로 비지역 정적 객체의 초기화 순서는 개별 번역 단위에서 정해진다.
	위 말을 해석하기 위해 먼저,
	정적 객체의 범주
		1. 전역 객체.
		2. 네임스페이스 유효범위에서 선언된 객체
		3. 클래스 내에서 static으로 선언된 객체
		4. 함수 내에서 static으로 선언된 객체			-> 지역 정적 객체
		5. 파일 유효범위에서 static으로 선언된 객체		-> 나머지는 비지역 정적객체
	
	번역 단위 : 컴파일을 통해 하나의 오브젝트 파일을 만드는 바탕이 되는 소스 코드.
	기본적으로는 소스 파일 하나가 되고, #include하는 파일들까지 합쳐서 하나의 번역 단위가 된다.

	따라서 여러개의 소스파일을 컴파일 하는데, 하나의 파일 내의 비지역 정적 객체의 초기화 과정에서 다른쪽 번역 단위의
	비지역 정적 객체가 사용된다면 초기화 되어 있지 않을 수 있다. -> 다른 번역 단위의 비지역 정적 객체간의 순서는
	정해져 있지 않기 때문. 순서를 정하는 방법? 없다.
	따라서 다른 해결법을 써야한다.
	-> 비지역 정적 객체를 하나씩 맡는 함수를 준비하고, 이 안에 각 객체를 넣는 것.
		함수속에서도 이들은 정적 객체로 선언하고, 그함수에서는 이들에 대한 참조자를 반환하게 만듦. 
		그리고 비지역 정적 객체를 직접 참조 하지말고 함수 호출로 대신하기.
	지역 정적 객체는 함수 호출중에 그 객체의 정의에 최초로 닿을 때 초기화 되도록 되어있음.
	추가로 해당 객체들을 호출할 일이 없다면 해당 객체들의 생성/소멸 비용도 생기지 않도록 막을 것!*/
	class FileSystem{};
	FileSystem& tfs()		//해당 함수로 tfs 객체를 대신함 + 클래스 안에 정적멤버로 들어가도 됨.
	{
		static FileSystem fs;	//지역 정정 객체를 정의하고 초기화
		return fs;				//이 객체에 대한 참조자 반환
	}

	class Directory 
	{
	public:
		Directory(/*생성자*/);
	};
	Directory::Directory()
	{
		unsigned iDisks = tfs().numDisks();   //반환된 정적 객체의 참조자를 활용
	}
	Directory& TempDir()
	{
		static Directory td;
		return td;
	}
	/*
		참조자를 반환하는 함수는 워낙 단순해서 호출빈도가 잦다면 인라인 함수로 해도 괜찮다.
		다만, 비상수 정적 객체는 다중 스레드 시스템에서는 장애가 생길 수  있다.
		이것을 해결하기 위한 방법으로, 다중 스레드로 돌입하기 전의 시동 단계에서 참조자 반환 함수를 전부 손으로
		호출해 줄 수 있다.
		
		이러한 참조자 반환 함수를 이용한 방법에 선행되어야 할 것이 내가 초기화 순서를 제대로 맞춰둔다는 것이다.
	*/