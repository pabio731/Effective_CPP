#include "pch.h"

/*
	템플릿은 코딩 시간의 절약과 코드의 중복 회피 두 마리 토끼를 잡는 문법이다.
	하지만 아무 생각 없이 사용하면 코드 비대화 문제가 초래 될 수 있다는 점을 알아야 한다.
	즉 중복되는 코드와 데이터가 목적 파일에 쌓일 수 있다는 것이다.
	따라서 이 부분에 대해서 고려하고, 미연에 방지할 수 있어야 한다.

	이를 고려하기 위해서 먼저 알아야 할 것은 공통성과 가변성 분석이다.
	이 부분은 사실 일반적으로 우리가 하던 것인데, 바로 우리가 코드를 작성하면서 중복되는 부분과
	그렇지 않은 부분을 나누어서 중복되는 부분은 따로 함수를 만들어서 중복되지 않은 코드 사이에서
	호출 시키는 것이다. 일반적인 함수와 클래스에서는 해당 코드들이 명시적으로 보이기 때문에 우리가
	잘 하지만 템플릿에서는 목적 파일이 커지는 것이기 때문에 우리 눈에 보이지 않는다.
	따라서 문제를 잘 인식하고 미연에 방지해야 한다.
	다음 코드를 보자. 고정 크기의 정방행렬을 나타내는 클래스 템플릿을 만드는데, 이 클래스 템플릿은
	역행렬 만들기 연산을 지원한다.
*/
template <typename T, std::size_t n>
class SquarMatrix
{
public:
	//...
	void Invert();		// 주어진 행렬을 그 저장 공간에서 역행렬로 만드는 멤버 함수
};
/*
	이 템플릿에서 눈에 띄는 것은 std::size_t 타입의 비타입 매개변수(non-type parameter)인 n도 받는 다는 것.
	이 템플릿을 사용하는 다음 코드를 보자
*/

int main()
{
	SquarMatrix<double, 5> sm1;
	sm1.Invert();					//SquarMatrix<double,5>::Invert를 호출
	SquarMatrix<double, 10> sm2;
	sm2.Invert();
}

/*
	이 떄, Invert의 사본이 인스턴스화되는데, 만들어지는 사본의 갯수가 두 개이다.
	하나는 5x5행렬에서, 하나는 10x10행렬에서 작동하는 함수이기 때문에 다른 함수이다.
	그러나 그외에는 모두 똑같다. 바로 이런 형태가 코드 비대화를 불러 일으키는 전형적인 상황이다.

	우리가 이렇게 사용하는 값만 다르고 나머지 다른 코드가 같은 함수가 눈에 보인다면 아마
	그 값을 매개변수로 받는 별도의 함수를 만들고, 숫자를 매개변수로 넘겨 호출하도록 만드려할 것이다.
	따라서 그 생각을 살려 코드를 보자
*/
template<typename T>
class SquareMatrixBase2
{
protected:
	//...
	void Invert(std::size_t MatrixSize);
	//..
};

template<typename T, std::size_t n>
class SquarMatrix : private SquareMatrixBase<T>
{
private:
	using SquareMatrixBase<T>::Invert;	//기본 클래스의 Invert가 가려지는 것을 막기 위한 코드
public:
	void Invert() { this->Invert(n); }	// Invert의 기본 클래스 버전에 대해 인라인 호출
	//위의 using을 이용하거나 this->를 이용하거나 둘 중에 하나만 해도 된다.
};

/*
	행렬의 크기를 매개변수로 받도록 바뀐 Invert함수가 기본 클래스인 SquareMatrixBase로 들어가고,
	SquarMatrixBase는 행렬의 원소가 갖는 타입에 대해서만 템플릿화 되어 있다.
	즉 같은 타입의 객체를 원소로 갖는 모든 정방행렬은 오직 한 가지의 SquareMatrixBase 클래스를 공유하게 되는 것.

	기본 클래스의 Invert함수는 파생 클래스에서 코드 복제를 피하기 위해 만든 것이기 때문에 protected 접근 지정이고,
	기본 클래스는 파생클래스를 구현을 돕는데만 쓰이기 떄문에 private 상속이라는 점도 알아두자.

	아직 해결못한 문제가 하나 있는데, 기본 클래스의Invert함수는 자신이 상대할 데이터(행렬)이
	어떤 것인지 어떻게 알 수 있는가? 크기를 매개 변수로 알아냈듯이 진짜 행렬의 메모리 위치도
	매개 변수로 받을 것인가? 하지만 위와 같이 설계를 했다면, 행렬의 크기와 상관없이 동작되는 것들은
	모두 기본 클래스에 구현 할 것이다. 그럼 그 모든 함수에 매개 변수를 추가 할 것인가 하는 문제가 생긴다.

	다른 방법으로 해결하도록 하자. 행렬 값들을 담는 메모리에 대한 포인터를 기본 클래스가 저장하게 하는 것이다.
	그리고 이 포인터른 저장하는김에 행렬의 크기도 저장하자.
*/

template <typename T>
class SquareMatrixBase3
{
protected:
	SquarMatrixBase3(std::size_t n, T* pMem)
		: size(n)
		, pData(pMem) {}

	void SetDataPtr(T* ptr) { pData = ptr; }
private:
	std::size_t Size;		// 행렬의 크기
	T* pData;				// 행렬 값에 대한 포인터
};

// 이렇게 설계하면 메모리 할당 방법의 결정 권한이 파생 클래스쪽으로 넘어간다.
// 파생 클래스를 만드는 사람에 따라 행렬 데이터를 SquareMatrix객체 안에 데이터 멤버로 직접 넣을 수도 있다.

template<typename T, std::size_t n>
class SquareMatrix2 : private SquarMatrixBase3
{
public:
	SquareMatrix2()
		: SquareMatrixBase3<T>(n, data) {}
	//...
private:
	T Data[n * n];
};

// 이렇게 파생 클래스를 만들면 동적 메모리 할당이 필요없는 객체가 되지만,
// 객체 자체의 크기가 좀 커질 수 있다. 따라서 다음과 같이 힙에 둘 수도 있다.

template <typename T, std::size_t n>
class SquareMatrix3 :private SquareMatrixBase3<T>
{
public:
	SquareMatrix3()
		: SquareMatrixBase3<T>(n, 0)
		, pData(new T[n * n])
	{
		this->SetDataPtr(pData.Get());		// 기본 클래스의 포인터를 널로 설정하고, 행렬 값의 메모리를 할당하고,
											// 파생 클래스의 포인터에 그 메모리를 물려 놓은 후, 이 포인터의 사본을 기본 클래스로 올려보냄.
	}

private:
	boost::scoped_array<T> pData;
};

/*
	SquareMatrix에 속해 있는 멤버중 상당수가 기본 클래스 버전을 호출하는 단순 인라인 함수가 될 수 있으며,
	똑같은 타입의 데이터를 원소로 갖는 모든 정방행렬들이 크기에 상관없이 기본 클래스 버전의 사본 하나를 고려한다는 것이 핵심

	추가적으로 저마다의 고유 타입도 가지기 때문에 실수를 컴파일러가 용납하지 않는다.

	하지만 행렬의 크기가 미리 녹아든 상태로 별도의 버전이 만들어지는 Invert와
	행렬 크기가 함수 매개변수로 넘겨지거나 객체에 저장된 형태로 다른 파생 클래스들이 공유하는 버전의 Invert함수
	두 가지를 비교하면 전자가 더 좋은 코드를 생성할 가능성이 높다.
	가장 단적인 예로 전자의 경우 행렬의 크기가 컴파일 시점에 투입되기 때문에 상수 전파(constant propagation)등의
	최적화가 먹혀 들어갈 가능성이 높다.

	반면 여러 행렬 크기에 대해 한 가지 버전의 Invert를 두도록 만들면 실행 코드의 크기가 작아지는 이점을 얻을 수 있다.
	이는 곧 프로그램 작업 세트(단순히 생각하면 프로세스가 현재 사용하는 메모리의 양)가 줄어든다는 뜻이다.
	이는 실행속도가 더 빨라지는 것으로 이어지는데 이러한 장점들은 크기 고정 버전의 Invert를 써서 얻을 수 있는
	이점과 비교했을 때, 더 큰 이점이라 생각할 수 있다.

	효율과 관련해 생각해볼 문제로 객체의 크기가 있는데, Invert 비슷한 크기 독립형 버전의 함수를 기본 클래스쪽으로
	아무 생각 없이 옮겨 놓다 보면, 각 객체의 크기가 슬그머니 늘어나는 문제가 생긴다.
	방금 본 코드만 해도 SqaureMatrix 객체는 메모리에 생길 떄마다 SquareMatrixBase  클래스에 들어 있는 데이터를 가리키는
	포인터를 하나씩 떠안고 있다. 결국 이것 때문에 객체 하나의 크기는 최소한 포인터 하나 크기만큼 낭비된 것이다.
	물론 포인터를 없애고 다른 방법을 이용할 수도 있겠지만, 당연히 얻는게 있으면, 잃을 점도 생길 수 있다는 것을 알아둬야 한다.

	추가적으로 위의 문제를 봤다고 해서 비타입 템플릿 매개변수는 코드 비대화의 원인은 아니다.
	간단한 예로 상당수의 플랫폼에서 int와 long의 이진 표현 구조가 동일한데
	vector<int>와 vector<long>의 멤버 함수는 서로 뺴다 박은 듯 똑같게 나올 수 있다.
	전형적인 코드 비대화 상황인데 이런 경우 어떤 링커는
	이렇게 동일한 표현구조를 가진 함수들을 합쳐주기도 한다.
	즉 코드 비대화가 어떤 환경이냐 따라서 일어날 수도, 일어나지 않을 수도 있다는 것이다.
*/