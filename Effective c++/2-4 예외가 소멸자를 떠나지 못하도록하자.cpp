/*
	C++자체가 소멸자로부터 예외가 터져나가는 것을 막는 것은 아니다. 하지만 우리는 막을 만한 당위성이 있다. 아래 예를 보자
*/
#include <vector>
class Widget
{
public:
	~Widget();			// 이 소멸자가 예외가 발생된다고 가정
};

void DoSomething()
{
	std::vector<Widget> v;
	// ...
}	// 함수의 끝, v가 소멸됨.

/*
	위와 같이 벡터가 소멸될 때, 자신이 거느리고 있는 모든 Widget을 소멸시킬 책임은 바로 이 벡터에게 있을 것이다.
	첫 번째 Widget을 소멸시키며 예외가 발생하고, 두 번째 객체가 삭제되면서 또 예외가 발생하게 되고, 이를 프로그램이 버티지 못해
	프로그램이 종료되거나 미정의 동작을 보이게 될 수도 있다. 이는 벡터와 같이 표준 라이브러리 컨테이너 뿐만 아니라 배열 등등을
	써서 생긴 것이 아니다. 순전히 예외가 터져나오는 소멸자 때문.
	아래 데이터베이스 연결을 나타내는 클래스를 보자
*/

class DBConnection
{
public:
	//...
	static DBConnection create();	//해당 객체를 반환하는 함수
	void close();					//연결을 닫고, 실패하면 예외를 던짐
};

/*
	위 예시는 사용자가 객체에 대해서 close를 직접 호출해야 하는 설계이다. 이를 잊는 것을 생각하여 만든다면
	DBConnection에 대한 자원 관리 클래스를 따로 만들어서 그 클래스의 소멸자에서 close를 호출하게 만드는 것일것.
	아래의 자원 관리 클래스 소멸자를 보도록 하자
*/

class DBConn		//DBConnection 객체를 관리하는 클래스
{
private:
	DBConnection db;
public:
	//...

	~DBConn() { db.close(); }		//연결이 항상 닫히도록 해주는 함수
};

/*
	여기서 close를 호출만 잘하면 문제될 것 없어 보이지만, close를 호출하고, 여기서 예외가 발생했다면 어떻게 되는가?
	DBConn의 소멸자가 예외를 전파할 것, 즉 예외가 소멸자를 나가도록 내버려 두는 것.
	이 걱정거리를 피하는 방법은 두 가지이다.

	1. close에서 예외가 발생하면 프로그램을 바로 끝내버린다. abort()를 호출하는 것
*/

DBConn::~DBConn()
{
	try { db.close(); }
	catch (/*...*/)
	{
		//close호출 실패 메세지
		std::abort();
	}
}

/*
	객체 소멸이 진행되다가 에러가 발생하여 더이상 프로그램을 진행할 수 없는 경우라면 괜찮다. 정의되는 동작을 막는다는 점에서 장점도 있다.

	2. close를 호출한 곳에서 일어난 예외를 삼겨버린다
*/

DBConn::~DBConn()
{
	try { db.close(); }
	catch (/*...*/)
	{
		//close호출 실패 메세지
	}
}

/*
	대부분의 경우에 예외를 삼키는 것(무시)은 별로 좋은 선택은 아니다. 중요한 정보가 묻혀버리기 때문에.
	무엇이 잘못됐는지 묻히는 것.
	만약 예외 이후에도 프로그램이 신뢰성 있게 작동한다면 미정의 동작보다는 나을 수 있다.

	어쨋든 둘다 문제가 있다... 중요한건 예외를 던지게된 요인에 대해 프로그램이 어떤 조치를 취할 수 있는가인데,
	이 부분에 대해 전무한 상태라서..

	조금 더 좋은 전략으로 DBConn인터페이스를 잘 설계해서 발생할 소지가 있는 문제에 대해 사용자가 대처할 기회를 주는 것이 있다.
	->DBconn에서 close를 직접 제공해서 사용자가 처리하거나	(멤버함수로 만들어서 실행가능)
	  닫혔는지의 여부를 통해서 소멸자에서 다시 닫게 하는 방법 등.	(bool타입 닫혔는지 여부를 나타내는 변수)
	어쨌든 여기서도 실패한다면 다시 위 2개의 방법으로 돌아가게 되지만...

	뭐가 어찌됐든 이 방법들은 예외를 처리할 필요가 있다면, 소멸자가 아니라 다른 함수에서 비롯되도록 하는 것이 핵심.
	소멸자에서 예외가 발생하면 미정의 동작이 생겨날 가능성이 높기 때문에!!
*/