/* 

	#define PI 3.14
	라는 매크로를 사용하는 예시를 생각해보자. 우리는 저 PI라는 이름을 알지만 컴파일러에게
	넘어가기도 전에 그저 3.14라는 상수로 바꾸어버릴 뿐이다. 따라서 기호 테이블에 들어가지 않기 때문에 상수로
	대체된 코드에서 컴파일 에러가 난다면 헷갈릴 여지가 생겨난다. 심지어 해당 매크로가 내가 작성한게 아닌
	다른 사람이 작성한 것이라면 더욱 더 문제가 될 수 있다. 따라서 매크로를 쓰는 것이 아닌
	const double Pi = 3.14 로 선언하는 것이 더 나을 수 있다.
	심지어 실수 타입의 데이터라면 크기도 더 작게 차지하게 된다. 다만, 이 경우 주의해야 할 것이 있는데, 
	1. 상수 포인터로 선언하는 경우 포인터는 물론 포인터가 가리키는 대상도 const로 선언해야 하는 것이 일반적이다.
			ex) const char* const MyName = "HaRam";
	2. 클래스 멤버로 상수를 정의할 때, 상수의 유효범위를 클래스로 한정하고자 할때, 해당 상수를 멤버로 만들어야 하는데,
	그 상수의 사본 개수를 단 하나로 만들고 싶다면 정적(Static) 멤버로 만들어야 한다.
ex)*/
class Player
{
private:
	static const int iNumTurns = 3;	//상수의 선언
	int Scores[iNumTurns];			//상수의 사용
};

/*	일단 위 iNumturns는 정의 된 것이 아니라 선언된 것임을 알고 있어야 한다. 보통 정의가 마련되어야 한지만
	정적 멤버로 만들어지는 정수류 타입의 클래스 내부 상수는 예외이다. 정의가 필요하다면
	const int Player::iNumTurn; 
	으로 정의하되, 헤더 파일이 아닌 구현 파일에 정의해야한다. 값은 선언시점에 주어지기 때문에 정의하며 
	값이 주어지면 안된다. (오래된 컴파일러라면 정의시 초기화 해야할 수 있다.)
	오래된 컴파일러에 대처하는 또 다른 방법이자 알아두면 좋은 기술이 있는데, 바로 "enum hack"을 사용하는 것이다.
	enum타입의 값은 int가 놓일 곳에 쓸 수 있다는 점을 활용하는 것.
ex)*/
class Player
{
private:
	enum{iNumTurns = 5};	//enum hack을 이용한 방법
	int Scores[iNumTurns];
};

/*	enum hack은 알아두면 굉장히 유용하게 쓰일 수 있는데, 그 이유로
	1. const보다는 #define에 더 가까운 방식이다. -> 주소를 얻는 것이 안된다. 필요에 따라 제약의 강화를 위해
	2. 쓸데없는 메모리의 할당을 막을 수 있다.
	
	#define 매크로의 또 다른 사례로 매크로 함수를 들 수 있다. 매크로 함수는 함수처럼 보이지만 함수 오버헤드
	일으키지 않으므로 활용하고자 할 수 있는데, 여러 문제가 있다. 일단 매크로 본문에 모든 인자마다 괄호를 
	씌어 주어야 하고, 아래와 같이 어처구니 없는 상황이 생기기도 한다*/
#define CALL_WIHT_MAX(a,b) ((a) > (b) ? (a) : (b))		//모든 인자에 괄호를 씌워주어야 하는 소소한 불편함
int main()
{
	int iTmp(5), iDst(0);
	CALL_WIHT_MAX(++iTmp, iDst);			//iTmp가 치환될 때+1 iDst와 비교 후 +1,
	CALL_WIHT_MAX(++iTmp, iDst + 10);		//iTmp가 치환될 때만 + 1
}   

//위와 같은 문제를 해결하기 위한 방법으로 인라인 한수에 대한 템플릿이 있다.
template<typename T> 
inline void CallWithMax(const T& a, const T& b)
{
	f(a > b ? a : b);
}
/*	일단 위 함수는 진짜 함수기 때문에 원래의 유효 범위, 접근 규칙을 따른다.
	C에서는 매크로 함수를 쓰지만 C++은 템플릿 덕분에 동작 방식도 알기 쉽고, 타입 안정성도 취할 수 있다.
	
	정리
	1. 단순한 상수는 const나 enum을 활용하자.
	2. 매크로 함수보다는 inline함수를 먼저 생각하자.
	
	*/