/*
	웹 브라우저를 나타내는 클래스가 하나 있다고 가정하자.
	그리고 갖가지 기능을 가진 함수들이 있다
*/

class WebBrowser
{
public:
	//...
	void ClearCache();		// 임시 저장 캐시를 비우는 함수
	void ClearHistory();	// 방문한 URL의 기록을 없애는 함수
	void RemoveCookies();	// 시스템이 갖고 있는 모든 쿠키를 제거하는 함수
};

// 또는 세 동작을 한 번에 하는 것을 위해 위 세 함수를 모아서 불러주는 함수를 만들 수도 있다.

class WebBrowser
{
public:
	void ClearEverything();		//위 세 함수를 호출하는 함수
};

/*
	물론 위 세 함수를 호출하는 함수를 객체를 인자로 받는 비멤버 함수로 만들어도 된다.
	이제 어느쪽이 더 나은 방법인지에 대해 생각해보자.

	일단 객체 지향 법칙에 따르면 데이터 그 데이터를 기반으로 동작하는 함수는
	한 데 묶여 있어야 하며, 멤버 함수가 더 낫다고 한다.

	하지만 그것이 항상 맞는 말은 아니다. 분명히 객체 지향 법칙은 할 수 있는만큼
	데이터를 캡슐화하라고 주장한다. 하지만 멤버 버전인 ClearEverything가
	비멤버 버전의 ClearEverything보다 캡슐화 정도에서 오히려 형편 없다고 생각할 수 있다.
	(해당 함수가 클래스내의 private 멤버에 접근이 가능하니까)
	추가로 비멤버 함수를 이용하면 WebBrowser관련 기능을 구성하는데 있어서 패키징 유연성(Packaging Flexibility)이
	높아지는 장점도 있고, 컴파일 의존도를 낮추고, 확장성 또한 높일 수 있다.

	캡슐화에 대해 생각해보자. 어떤 것을 캡슐화하면 외부에서 이것을 볼 수 없다.
	그리고 캡슐화 하는 것이 늘어나면 그만큼 밖에서 볼 수 있는 것이 줄어든다.
	그리고 밖에서 볼 수 있는 것이 줄어들면 그것들을 바꿀 때 필요한 유연성이 커진다.
	변경을 한다는 것이 영향을 줄 수 있는 범위가 "변경된 것을 볼 수 있는 것들"로 한정되기 때문에.
	즉 코드를 바꾸더라도 제한된 사용자들에게만 영향이 간다는 것.

	그렇다면 어떤 객체의 모습을 해당 객체의 데이터(변수들)로 설명할 수 있다고 생각해보자.
	이 데이터를 볼 수 있는 코드가 적으면 적을수록 그 데이터는 많이 캡슐화된다는 것이고,
	그 객체가 가진 데이터의 특징(멤버의 수 , 타입 등)을 바꿀 수 있는 자유도가 그만큼 높은 것이다.
	즉 해당 코드를 많은 함수가 볼 수 있다 -> 많은 영향을 주게 된다.
	해당 코드를 많은 함수가 볼 수 없다 -> 적은 영향을 주기 때문에 자유도가 높다.

	private멤버에 접근할 수 있는 함수의 개수를 예측하는 것은 멤버 함수와 프렌드 함수만
	더하면 되기 때문에 쉽다.

	이제 똑같은 기능을 제공하는데 해당 클래스의 private 멤버, 나열자,  typedef 타입 등등 모두 접근 가능한
	멤버 함수를 쓸 것인지에 대해 다시 생각해보자.
	당연히 비멤버 비프렌드 함수가 더 캡슐화의 정도가 높다.

	다만! 여기서 두 가지에 주의해야한다.
	1. 이 이야기는 비프렌드 함수에만 적용된다.
		프렌드 함수는 private멤버에 대한 접근권한이 해당 클래스의 멤버 함수가 가진 접근 권한과 같기 때문에
		캡슐화에 대한 영향 역시 같다. 지금 여기서 하는 이야기는 멤버 함수와 비 멤버 비프렌드 함수에 대한
		이야기인 것이지 프렌드 함수와 관련된 것이 아니다.

	2. 캡슐화에 대한 이런 저런 이야기 때문에 "함수는 어떤 클래스의 비멤버가 되어야 한다" 라는 주장이
	   "그 함수는 다른 클래스의 멤버가 될 수 없다"라는 의미가 아니다.
	   위 예시의 ClearEverything함수를 유틸리티 클래스의 static멤버 함수로 만들어 쓰는 방법도 있다.
	   ClearEverything가 WebBrowser의 멤버(또는 프렌드 함수)만 아니면 된다는 것.

	 다른 방법으로 아래 코드를 보자
*/

namespace WebBrowserStuff
{
	class WebBrowser {};

	void ClearBrowser(WebBrowser& wb);
	//...
}
/*
	이렇게 ClearBrowser를 비 멤버 함수로 두되, 어떤 네임 스페이스 안에 두는 것.
	이 방법은 네임스페이스가 여려개의 소스 파일에 나뉘어 흩어질 수 있기 때문에,
	더 나아간 방식으로 생각할 수 있다.
	문제가 되는 위 함수는 편의상 준비한 함수의 일종인데, 멤버도 아니고 프렌드도 아니기 때문에
	WebBrowser 사용자 수준에서 아무리 애를 써서 얻어낼 수 없는 기능은 이들도 제공할 수 없다.

	또한 응용도가 높은 클래스는 이런 종류의 편의 함수가 꽤 많이 생길 수 있다.
	사용자는 그 중 몇개만 알고 있거나 관심을 두기 마련인데 일부러 그외의 다른 함수에 대해서
	생각하고 고민할 필요가 없어진다는 것이다.

	가장 쉽고 깔끔한 방법은 편의 함수를 하나의 헤더에 몰아서 선언하고, 또 다른 편의 함수를
	다른 헤더 파일에 몰아서 선언하는 것.

	실제로 표준 C++라이브러리가 이런식으로 되어 있다. std네임스페이스에 속한 모든 것들이
	한통에 섞여있지 않고, 많은 헤더(<vector>, <algorithm>, <memory>등등)에 흩어져있다.

	이런 방식을 사용하면 사용자가 실제로 사용하는 구성요소에 대해서만 컴파일 의존성을 고려할 수 있다.
	또한 확장도 필요한 헤더에 추가하거나, 새로운 헤더를 만들거나 하는 방식으로 할 수 있기 때문에 쉽다

*/