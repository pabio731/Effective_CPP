#include<iostream>
/*
	프로그래밍에서 자원이란 사용을 마치고 나면 돌려주어야 하는 것이다. 돌려주지 않으면 안좋은 일들이 하나씩
	생겨나는 것이 자원! 가장 일반적으로는 동적할당을 통해 얻은 메모리를 생각할 수 있는데, 그 외에도
	파일 서술자(file descriptor), 뮤텍스 잠금(mutex lock), 그래픽 유저 인터페이스(graphical user interface)에서의 폰트와 브러시,
	데이터 베이스 연결, 네트워크 소켓까지 모두 자원에 해당한다.

	자원 관리중에서도 사용한 자원을 놓아주는 것은 생각보다 어려운 일이다. 예외도 고려해야하며, 많은 return문이 들어간 함수 작성하다보면
	어떤 실수를 하게 될지 모른다.
	따라서 더 효과적으로 자원을 관리하기 위해 클래스의 생성자, 소멸자, 객체 복사 함수를 이용하자.
	즉 객체를 이용해서 자원을 이용하도록 하자.

	투자를 모델링 해주는 클래스 라이브 러리를 가지고 어떤 작업을 한다고 가정하자
	최상위에 Investment라는 클래스가 있고, 구체적인 형태의 투자 클래스의 파생을 보자.
*/

class Investment {/*...*/ };		//최상위 클래스

//최상위 클래스 계통에 속한 클래스의 객체를 동적 할당하고, 그 포인터를 반환. 이 객체의 해제는 호출자쪽에서 직접 해야함
Investment* CreateInvestment();

void f()
{
	Investment* pInv = CreateInvestment(); // 팩토리 함수를 호출
	//...
	delete pInv;	//객체를 해제
}

/*
	위 코드는 멀쩡해 보이지만 팩토리 함수로부터 얻은 투자 객체의 삭제에 실패할 수 있는 경우가 많다.
	1. delete에 도달하기 전에 return이 있을 수도 있다.
	2. 팩토리 함수와 delete가 루프안에 있고, continue나 분기문에 의해 루프에서 빠져나올 수도 있다.
	3. delete에 도달하기전에 예외가 발생할 수도 있다.

	물론 꼼꼼하게 코드를 짠다면 문제를 예방할 수 있지만, 몰려드는 일 속에서 놓칠 수도 있는 부분이다.
	코드의 진행이 delete까지 무사히 도달할 것이라 믿지 않는 편이 좋다.

	그럼 어떻게 자원이 항상 해제되도록 할 수 있을까?
	바로 자원을 객체에 넣고, 객체의 소멸자를 이용하는 것이다.
	해당 소멸자는 함수 f()가 끝날 때 호출되도록 하여 저절로 해제되도록 만들자.

	개발의 상당수의 자원이 힙에서 동적으로 할당되고, 하나의 블록이나 함수 안에서만 쓰이는 경우가 많기 때문에
	해당 블록이나 함수에서 벗어날 때 자원이 해제되도록 하는 것이 맞다.
	표준 라이브러리에 auto_ptr이란 것이 있는데, 바로 이런 용도로 쓰라고 마련된 클래스이다.
	auto_ptr은 포인터와 비슷하게 동작하는 객체(스마트 포인터)로, 가리키고 있는 대상에 대해서 소멸자가 자동으로
	delete를 불러주도록 설계되어 있다. 다음은 이를 사용한 코드이다.
*/

void f()
{
	std::auto_ptr<Investment> pInv(CreateInvestment());	//팩토리 함수를 호출

	//pInv를 사용 ...
}		//auto_ptr의 소멸자를 통해서 pInv가 삭제됨.

/*
	자원 관리에 객체를 이용하는 방법의 중요한 두 가지 특징을 볼 수 있다.
	****** 1. 자원을 획득한 후에 자원 관리 객체에게 넘긴다.  ******
	위 코드는 팩토리 함수가 만들어 준 자원을 그 자원을 관리하는  auto_ptr 객체를 초기화 하는데 쓰이고 있다.
	이렇게 자원관리에 객체를 이용하는 아이디어에 대한 업계 용어로 "자원 획득은 초기화이다", RAII 라고 한다.
	자원의 획득과 객체의 초기화가 한 문장에 이루어지는 것이 일상적이라 나온 용어.

	****** 2. 자원 관리 객체는 자신의 소멸자를 사용해서 자원이 확실히 해제되도록 한다. *******
	소멸자는 어떤 객체가 소멸될 때(유효범위를 벗어나는 경우도) 자동적으로 호출되기 떄문에 실행 제어가
	어떤 경위로 블록을 떠나는지와 무관하게 자원을 해제할 수 있다.

	auto-ptr은 자신이 소멸될 때 자신이 가리키고 있는 대상에 대해 자동으로 delete를 먹이기 때문에 절대
	어떤 객체를 가리키는 auto_ptr의 개수가 둘 이상이면 안된다.

	auto_ptr의 특이한 특징으로 객체를 복사하면 원본 객체는 null로 만든다는 것이다. 이는 복사하는 객체만이
	유일한 소유권을 갖는다고 가정하기 때문이다.
*/

std::auto_ptr<Investment> pInv1(CreateInvestment());	// pInv가 가리키는 대상은 팩토리 함수에서 반환된 객체
std::auto_ptr<Investment> pInv2(pInv1);		// pInv2가 객체를 가리키게 되고 pInv1는 null이 된다.
pInv1 = pInv2;				// 다시 pInv1이 객체를 가리키게 되고, pInv2가 null이 된다.

/*
	이런 특징 떄문에 모든 자원에 대해서 auto_ptr을 쓰는 것이 최선은 아니다. 예를 들어 STL 컨테이너의 경우
	원소들이 정상적이 복사 동작을 가져야 하기 때문에 다른 방식을 써야한다.

	그 대안으로 참조 카운팅 방식 스마트 포인터(RCSP)가 있다.
	RCSP는 특정한 자원을 가리키는 외부 객체의 개수를 유지하고 있다가 개수가 0이 되면 해당 자원을
	자동으로 삭제하는 스마트 포인터. 가비지 컬렉션과 유사한 동작을 하지만 서로 다른 두 객체가 서로를
	참조하는 경우 없앨 수는 없다는 점에서 차이를 보인다.

	대표적인 RCSP는 TR1의 tr1::shared_ptr
*/
void f()
{
	//...
	std::tr1::shared_ptr<Investment> pInv(CreateInvestment());
	//... 사용
}	// shared_ptr의 소멸자를 통해 자동으로 삭제

void f()
{
	//...
	std::tr1::shared_ptr<Investment> pInv1(CreateInvestment());
	std::tr1::shared_ptr<Investment> pInv2(pInv1);	//pInv1과 pInv2가 동시에 같은 객체를 가리키고 있음.
	pInv1 = pInv2;			//마찬가지
}	//pInv1, pInv2 와 이들이 가리키고 있는 객체도 삭제됨.

/*
	이 2개의 스마트 포인터를 사용할 때 조심해야 할 것이 delete연산을 사용한다.
	delete[]가 아니기 때문에 동적 배열에 대해서는 사용할 수 없다.
	표준 라이브러리에서는 동적 배열을 삭제하기 위해 준비된 클래스가 없다.
	왜냐하면 vector, string으로 대체 가능하기 때문에...
	굳이 찾자면 부스트에는 있다.

	추가적으로 상황에 따라서는 자원 관리 클래스를 직접 만들 수밖에 없다. 이 경우 세심하게 만들어서
	문제가 생기지 않도록 하자.
*/