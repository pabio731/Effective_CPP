#include<iostream>
#include <mutex>
/*
	3-1에서 공부한 auto_ptr, shared_ptr 두 가지는 힙 메모리를 사용하는 자원에 대해서는 괜찮지만
	모든 자원이 힙메모리를 이용하지는 않는다. 바로 그런 경우가 직접 자원 관리 클래스를 만들어야 하는 상황이다.

	Mutex타입의 뮤텍스 객체를 조작하는 C API 를 사용하는 중이라 가정하자.
	제공되는 함수에응 lock, unlock이 있을 것이다.
*/

void lock(std::mutex* pm) {}	// pm을 가리키는 뮤텍스에 잠금을 검.
void unlock(std::mutex* pm) {}  // pm을 가리키는 해당 뮤텍스의 잠금을 품
/*
	이전에 걸어놓은 뮤텍스 잠금을 잊지 않고 풀어주기 위해서 뮤텍스 잠금을 관리하는 클래스를 하나 만들어 준다고 하자.
	이 용도의 클래스는 기본적으로 RAII법칙을 따라 구성한다.
	생성시에 자원을 획득하고, 소멸시에 자원을 해제하는 것.
*/

class Lock
{
public:
	explicit Lock(std::mutex* pm) : mutexptr(pm) { lock(mutexptr); }	//자원을 획득

	~Lock() { unlock(mutexptr); }		// 자원을 해제

private:
	std::mutex* mutexptr;
};

//	사용자는 Lock을 사용할 때 RAII방식을 맞추면 된다.

std::mutex m;
//...
{	//임계 영역을 정하기 위한 블록
	Lock m1(&m);		// 객체를 생성하면서 뮤텍스 잠금

	//...		임계영역에서 할 연산 행
}	// 블록의 끝에서 잠금이 자동으로 해제

/*
	잘될 것 같아 보인다. 하지만 만약 Lock객체가 복사된다면 어떻게 해야하는가?

	****** 1. 복사를 금지한다. ******
	실제로 RAII 객체가 복사되도록 놔두는 것 자체가 말이 안되는 경우가 꽤 많다. 위 코드도 마찬가지
	스레드 동기화 객체에 대한 '사본'은 없으니...
	복사를 막는 방법은 이전에 공부한 Uncopyable 클래스와 상속을 이용해서 하면 된다.

	****** 2. 관리하고 있는 자원에 대해 참조 카운팅을 한다. ******
	자원을 사용하는 마지막 객체가 소멸될 떄까지 그 자원을 저 세상으로 안 보내는게 바람직할 경우도 종종 있다.
	이 경우 해당 자원을 참조하는 객체의 개수에 대한 카운트를 증가시키는 식으로 RAII 객체의 복사 동작을 만들어야 한다.
	tr1::shared_ptr이 이방식.

	따라서 tr1::shared_ptr 을 클래스의 데이터 멤버로 넣어서 참조 카운팅 방식을 생각해 볼 수 있다
	위의 코드에서 mutexptr의 타입을 mutex*에서 tr1::shared_ptr<mutex>로 바꾸는 것.
	하지만 tr1::shared_ptr은  참조 카운트가 0이 되면 대상이 삭제가 된다. 위의 예에서
	mutex를 다 썻을 때, 잠금해제만 하고 삭제는 하지 않는 방법으로 tr1::shared_ptr의  두 번째 매개변수
	(삭제자 지정)을 이용하면 된다. 삭제자는 tr1::shared_ptr이 유지하는 참조 카운트가 0이 됐을 때
	실행하는 함수나 함수 객체를 말하는 것.
*/

class Lock2
{
public:
	explicit Lock2(std::mutex* pm) : MutexPtr(pm, unlock)
	{
		Lock(MutexPtr).get());		//get의 내용은 다음 장에서...
	}
private:
	std::tr1::shared_ptr<std::mutex> MutexPtr;
};

/*
	위 코드에서 잘 보아야 하는 것은 Lock2 클래스가 소멸자를 선언하지 않는 다는 점. 필요가 없기 때문에
	MutexPtr의 소멸자는 뮤텍스 참조가 0이 됐을 때 tr1::shared_ptr의 삭제자를 자동으로 호출

	****** 3. 관리하고 있는 자원을 진짜로 복사한다 ******
	상황에 따라서는 자원을 원하는 대로 복사할 수도 있다.
	자원을 다썼을 때 각각의 사본을 확실히 해제한다는 점만이 자원 관리 객체의 유일한 이유가 되는 것.
	자원 관리 객체를 복사하면 그 객체가 둘러싸고 있는 자원까지 "깊은 복사"가 되어야 한다.

	****** 4. 관리하고 있는 자원의 소유권을 옮긴다. ******
	흔한 경우는 아니다. 실제로 자원을 참조하는 RAII객체를 하나만 하고 싶어서
	사본에게 자원을 소유권을 넘기는 것 ->> 바로 auto_ptr의 동작 (복사를 하면 이전의 auto_ptr이 NULL이 되는...)

*/