



/*
	클래스의 복사 생성자, 복사 대입 생성자, 소멸자는 우리가 선언하지 않으면 컴파일러가 자동으로 기본형으로 선언해버린다.
	그리고 이렇게 생겨난 것들은 모두 접근 지정이 public이고, inline 함수이다.
	결국 쉽게 말해  class Empty{]; 이렇게 선언 했다면 다음과 같이 선언한 것이나 마찬가지라는 것이다.
*/
class Empty
{
public:
	Empty(){}								//기본 연산자
	Empty(const Empty& rhs){}				//복사 생성자
	~Empty() {}								//소멸자
	Empty& operator=(const Empty& rhs){}	//복사 대입 연산자
};
int main()
{
//	다음은 이들이 만들어 지는 조건 코드
Empty e1;		//기본 생성자와 소멸자
Empty e2(e1);	//복사 생성자.
e2 = e1;		//복사 대입 연산자
}

/*
	그렇다면 왜 저절로 만들어지도록 했을까? 
	기본 생성자와 소멸자가 하는 일은 기본적으로 컴파일러에게 "배후의 코드"를 깔 수 있는 자리를 마련하는 것.
	배후의 코드란 기본 클래스 및 비정적 데이터 멤버의 생성자와 소멸자를 호출하는 코드.
	이때 만약 기본 클래스의 소멸자가 가상 소멸자가 아니라면 해당 클래스의 소멸자도 비가상 소멸자로 만들어진다.

	그럼 복사 생성자와 복사 대입 생성자는?
	이들은 원본 객체의 비정적 데이터를 사본 객체쪽으로 그냥 복사하는 것이 전부.
	근데 복사하려는 데이터 멤버에 참조자가 있으면 말이 달라진다.
	하나의 객체를 복사하면서 해당 객체의 데이터 멤버를 참조하게 된 뒤, 다른 객체의 복사가 이루어진다면, 
	데이터 멤버의 참조는 무엇을 가리켜야 하는가?의 문제. 이 경우 컴파일 오류가 생김. 상수의 경우에도 마찬가지
	따라서 참조자나 상수 데이터 멤버를 가지는 경우 복사 대입 연산자를 직접 정의 해줘야한다.

	추가적으로 복사 대입 연산자를 private로 선언한 클래스로 부터 파생된 클래스의 경우 암시적 복사 대입 연산자를 
	가질 수 없게 된다는 점도 알아두자.
*/

