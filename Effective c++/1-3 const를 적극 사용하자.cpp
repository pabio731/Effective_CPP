/*
	const가 붙으면 외부 변경이 불가능하며, 이 제약을 컴파일러가 단단히 지켜준다는 점은 아주 중요한 특징이다.
	이에 따라 const는 다른 프로그래머에게 "이 값은 변경되어서는 안된다" 라고 알려주는 메세지이기도 하다.
	
	상수 포인터, 포인터가 가리키는 대상의 상수화를 쉽게 아는 법.
	선언에서 "*" 왼쪽에 const가 있으면 포인터가 가리키는 대상 자체가 상수, "*" 오른쪽에 const가 있으면 포인터가 상수이다.
*/
	int iArray[3] = {1,2,3,};
	int *p = iArray;			//비상수 데이터, 비상수 포인터
	const int *p = iArray;		//상수 데이터,   비상수 포인터  -> int const *p도 같은 의미
	int* const p = iArray;		//비상수 데이터, 상수 포인터
	const int* constp = iArray; //상수 데이터,   상수 포인터
/*
	STL 반복자는 포인터를 본뜬 것이라 기본적인 동작원리가 포인터와 같다. 
	따라서 반복자를 상수로 선언하는 것은 자신이 가리키는 대상은 변경 할 수 없지만, 가리키고 있는 대상의 데이터는 변경 가능
	자신이 가리키고 있는 대상의 데이터 변경을 불가능하게 하고 싶다면 const_iterator을 쓰자.
	const std::vector<int>::iterator iter -> 대상의 데이터 변경 가능, 자신이 무엇을 가리키는지 변경 불가능.
	std::vector<int>::const_iterator iter -> 대상의 데이터 변경 불가능, 자신이 무엇을 가리키는지 변경 가능.

	1. 함수 선언에서의 const 
		함수에서 const는
		1. 반환 값
		2. 매개변수					
		3. 멤버함수				
		4. 함수전체 에 const 성질을 붙일 수 있다.

	상수 반환 값을 가지는 함수는 안전성이나 효율을 포기하지 않고 사용자 측의 에러 돌발 상황을 줄이는 효과가 있음.
	단적인 예로, 연산자 오버로딩을 하고, 그 것을 활용하는 과정에서 볼 수 있는데 Circle 클래스가 있고,
	const Circle operator*(const Circle& Rect1, const Circle& Rect2)
	Circle Src, Dst, Tmp;
	(Src * Dst) = Tmp		//상수로 선언했기 때문에 에러 발생. Src*Dst 는 상수. 상수에 대입하려 했기 때문에 에러 발생
	위와 같은 코드는 상식적으로 맞지 않지만 오타로 인해 생겨날 수 있다. 이때 상수 반환타입의 함수 덕분에 우리가 모르고
	지나가는 것을 미연에 방지 할 수 있다.

	2. const 매개변수
	const 매개변수는 일반적인 const지역객체와 똑같이 생각하면 되고, 가능하면 항상 사용 할 것. 
	const 덕분에 연산자 실수도 잡아 낼 수 있고, 다른 이에게 이 매개변수는 값이 변경되면 안된다는 사실 또한 전달할 수 있다.


	3. 상수 멤버 함수
	멤버 함수에서의 const 함수의 역할은 해당 멤버 함수는 "상수 객체에 의해 호출될 함수"라는 뜻.
	이것이 중요한 이유는 
		1. 클래스의 인터페이스를 이해하기 좋게 하기 위해서.
		-> 해당 클래스의 객체를 변경 할 수 있는 함수와 변경 할 수 없는 함수에 대한 구분.
		2. 상수 객체가 사용하는 함수라는 것. 
		-> "상수 객체에 대한 참조"를 통해 성능을 높일 수 있다는 점에서 (변수라면 call by value에 의한 복사, 객체는 복사 생성자)
			객체를 매개 변수로 보낼 때 const Object& Obj 이런식으로 쓰이게 되는데,
			이때, 전달된 객체는 상수 객체로 보내졌으니 상수 멤버 함수가 필요.
			상수 객체에 대한 포인터에서도 사용.

	상수 멤버라는것은 비트수준 상수성(물리적 상수성), 논리적 상수성이라는 두개의 개념이 중요하다.
	 -비트 수준 상수성은 멤버 함수가 해당 객체의 어떤 데이터 멤버도 건드리지 않아야 그 멤버 함수가 const 함수라고 인정하는것
	(단, static 멤버는 제외)
	c++의 정의하는 상수성이 이 비트수준 상수성임. 이 개념의 위반을 찾는 것은 그냥 대입 연산이 이루어졌는가만 확인하면
	되기 때문에 찾기 쉬운 편에 속하는데, 문제는 해당 const 멤버 함수가 해당 클래스의 포인터 멤버 변수를 이용해서
	값을 변경할 수 있다. (반환 타입에 참조를 붙이고, 포인터를 이용해서 참조자보내 해당 함수를 호출하는 함수 또는 포인터를
	이용해 변경 할 수 있게 되는 것)
	
	-논리적 상수성은 위와 같은 상황을 보완하는 대체 개념으로 나온 것. 아예 수정이 안되게 하는 것이 아니라 약간의 수정이 되고, 
	 그것이 사용자가 모르게 하는 것이라면 const 멤버 함수의 자격으로 충분하다.
	 예시 */
	#include<iostream>
	class CTextBook
	{
	public:
		unsigned int Length() const;

	private:
		char* pText;
		/*mutable*/ unsigned int iTextLength;			//바로 직전에 계산한 텍스트 길이
		/*mutable*/ bool bLengthIsValid;				//현재 이 길이가 유효한가
	};
	
	unsigned int CTextBook::Length() const
	{
		if (!bLengthIsValid)
		{
			iTextLength = std::strlen(pText);		//상수 멤버 함수 안에서 
			bLengthIsValid = true;					// 두 값을 변경하려 하므로 에러!
		}
		return iTextLength;
	}
	
/*
	위 함수는 변경이 값의 변경이 있더라도 상수 객체에서 대해서 문제 없는 코드이다.
	하지만 상수 함수에서 값 변경을 하려 하기 때문에 컴파일러가 에러를 출력한다.
	
	이에 대한 해답으로 mutable 키워드를 사용할 수 있다. mutable은 비정적 데이터 멤버를 비트 수준 상수성에서 해방시켜줌.
	해당 변수들을 선언할 때 mutable을 넣어주어 상수 멤버 함수에서도 값 변경이 가능하게 된다.
	 
	하지만 함수를 상수 멤버 함수와 비상수 멤버 함수 버전으로 코드만 같고 상수성만 다르다면 중복된 코드로 효율적이지 못하게 된다.
	이 경우 상수성을 떼어주는 const_cast를 이용할 수 있다. (일반적으로 캐스팅은 최소로 해야함을 알고 있자)
	캐스팅을 사용하더라도 안전성을 유지하며 코드 중복을 피하는 방법 -> 비상수 멤버 함수가 상수 멤버 함수를 호출하게 한다.
*/
	class Textblock
	{
	public:
		const char& operator[](unsigned int iPosition) const;  //{~~~return text[iPosition] }
		const char& operator[](unsigned int iPosition)
		{
			return const_cast<char&>(static_cast<const Textblock&>(*this)[iPosition]);
		}	//비 상수 멤버 함수에서 상수 멤버 함수를 상수성을 제거하고 호출
	};
/*
	위 코드에서 두 번의 캐스팅을 하는데 이유는 비 상수 멤버 함수에서 상수 멤버 함수를 호출하는 직접적인 방법이 없기 때문.
	그래서 *this타입을 캐스팅해 TextBlock을 const TextBlock으로 바꾸어주는 것. 이후 const_cast를 통해 operator[]의
	반환값에서 const를 떼어 놓는 것.
	추가적으로 위와 같이 비상수 멤버함수에서 상수 멤버 함수를 호출하는 방식으로 해야 더 안전하다. 반대는 금지
*/
		


