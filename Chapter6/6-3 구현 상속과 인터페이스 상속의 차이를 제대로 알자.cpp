#include "pch.h"

/*
	상속이라는 개념은 함수 인터페이스의 상속, 함수 구현의 상속 이렇게 두 가지로 나뉜다.
	클래스 설계자의 입장에서 보면 멤버 함수의 인터페이스만을 파생 클래스가 상속하고 싶을 때가 분명히 있다.
	어떤 경우에는 함수의 인터페이스와 구현 모두를 상속 받고 그 상속받은 구현이 오버라이딩 가능하게 만들었으면 하는 경우도 있을 것
	또 어떤 경우는 인터페이스와 구현을 상속받되 어떤 것도 오버라이드 할 수 없도록 막고 싶은 경우도 있을 것이다.

	다음 그랙픽 프로그램에서 쓰이는 기하학적 도형을 나타내는 클래스 계통구조를 보자
*/
class Shape
{
public:
	virtual void Draw() const = 0;
	virtual void Error(const std::string& Msg);
	int ObjectID() const;
};

class Rectangle :public Shape {};
class Ellipse : public Shape {};

/*
	일단 먼저 체크해야 할 것이 Shape클래스는 Draw에 의해 추상 클래스라는 것이다. 아무 힘도 없을 것 같은
	이 Shape가 파생 클래스에 대해 미치는 영향은 굉장히 크다.
	왜냐면 멤버 함수 인터페이스는 항상 상속받게 되어있기 때문이다.
	public 상속은 is-a관계이기 때문에 어떤 클래스에서 동작하는 함수는 그 클래스의 파생 클래스에도 동작해야 한다.

	Shpae클래스의 세 개의 함수에 대해 생각해보자. 위 세 개 함수는 선언된 방법도 각기 다르다.
	그렇다면 이렇게 다른 선언 방법들에 대한 속뜻은 무엇일까?

	우선 순수 가상함수인 Draw에 대해 생각해보자
	순수 가상함수에서 가장 두드러지는 특징은 두 가지이다.
	1. 순수 가상 함수를 물려받은 구체 클래스가 해당 순수 가상 함수를 다시 선언해야 한다.
	2. 전형적으로 추상 클래스 안에서 정의를 갖지 않는다. (정의 가능하긴 함)
		-> 종합하면 파생클래스에게 함수의 인터페이스만을 물려주려는 목적으로 이해할 수 있다.

	위 Draw를 생각해보면 모든 shape는 그리기가 가능해야 하지만, 구체적인 모양이 없는Shape에서는
	그릴 방법이 없다. 그리고 타원을 그리는 알고리즘과 직사각형을 그리는 알고리즘이 같을 수 없다.
	즉 Shape로부터 구체 클래스를 파생시킬 설계자에게 "Draw함수는 직접 제공할 것, 어떻게 구현되든지 관심없음"과 같은 것

	순수 가상함수도 기본 클래스에서 구현이 가능한데, 이를 호출하고자 한다면 스코프 연산자를 이용하면된다.
	나중에 가상함수에 대한 기본 구현을 종전보다 안전하게 제공하는 메커니즘으로 활용 가능하다.

	다음은 단순 가상 함수에 대해 생각해 보자.
	가상 함수는 파생 클래스로 하여금 함수의 인터페이스를 상속하게 한다는 점은 똑같지만, 파생 클래스쪽에서 오버라이드 할 수 있는
	함수 구현부도 제공한다는 점이 다르다.
	즉. 파생 클래스로 하여금 함수의 인터페이스뿐만 아니라 그 함수의 기본 구현도 물려받데 하자는 것.

	Shape::Error함수가 전달하는 바는 다음과 같다.
	실행중에 에러와 마주쳤을 때 자동으로 호출될 함수를 제공하는 것은 모든 클래스가 해야할 일이지만 꼭 각 클래스마다 그때 그때
	꼭 맞는 방법으로 에러를 처리할 필요는 없다는 것. 상황에 따라 Shape에서 기본 제공하는 에러처리를 써도 된다.

	사실 가상 함수에서 함수 인터페이스와 기본 구현을 한꺼번에 지정하도록 하는 것은 위험할 수 있다.
	예를 들어 XYZ항공사가 있고, A모델, B모델의 비행기를 가지고 있다고 생각하자
*/
class Airport {};	//공항을 나타내는 클래스

class Airplane
{
public:
	virtual void fly(const Airport& Destination);
};
void Airplane::fly(const Airport& Destination)
{
	// 주어진 목적지로 비행기를 날려보내는 기본 동작원리를 가진 코드
}

class ModelA :public Airplane {};
class ModelB :public Airplane {};

/*
	fly가 가상함수로 선언되어 있는 것을 볼 수 있다. 모든 비행기는 fly함수를 지원해야 한다는 점을 나타내야 하기 때문에...
	또 모델이 다른 비행기는 원칙상 fly 함수에 대한 구현을 저마다 다르게 요구할 수 있다는 사실을 알고 있다는 뜻도 된다.
	하지만 A와B가 코드가 중복되는 것을 막기 위해 기본적인 동작원리를 fly본문에 제시함으로 두 모델 클래스가 물려받을 수 있도록 했다.

	지극히 고전적인 객체 지향 설계이다. 두 클래스가 하나의 공통 특징을 공유하고 있으므, 그 특징을 기본 클래스로 올리고 두 클래스가
	물려받도록 설계한 것. 이런 설계는 공통적인 특징이 명확해지고, 코드 중복을 막으며, 기능 개선의 여지도 열려있는 데다가, 장기적인 유지 보수도 쉬워진다.

	하지만 새로운 모델C가 들어왔고 이 모델은 비행 방식이 완전 다르다고 생각해보자.
	그리고 프로그래머들이 모델 C를 기존 클래스 계통에 추가했지만, fly함수를 재정의하는 것을 깜빡했다면??
	C모델에서 Airplane::fly가 호출이 될 것이다.
	이는 A와 B모델과 다른 비행 방식을 가진 C모델에게는 치명적인 문제이다.

	이 문제는 fly함수가 기본 동작을 구현해서 생긴 문제가 아니라 C모델 클래스는 이 동작을 원한다고 명시적으로 밝히지 않았는데도
	이 동작을 물려 받는데 아무 걸림돌이 없다는 것이다.
	이 방법을 해결하는 것은 어렵지 않은데 가상 함수의 인터페이스와 그 가상 함수의 기본 구현을 잇는 연결관계를 끊어버리면 된다.
*/

class Airplane2
{
public:
	virtual void fly(const Airport& Destination) = 0;

protected:
	void DefaultFly(const Airport& Destination);
};
void Airplane2::DefaultFly(const Airport& Destination)
{
	// 주어진 목적지로 비행기를 날려보내는 기본 동작원리를 가진 코드
}

/*
	fly 함수가 순수 가상 함수로 바뀌고, 기본 동작 원리를 가진 함수는 protected에 비가상함수로 선언했다.
	모델A,B는 그냥 fly함수 본문에서 그냥 DefaultFly함수를 호출하면 된다.
*/

class ModelA2 : public Airplane2
{
public:
	virtual void fly(const Airport& Destination)
	{
		DefaultFly(Destination);
	}
};

class ModelB2 : public Airplane2
{
public:
	virtual void fly(const Airport& Destination)
	{
		DefaultFly(Destination);
	}
};
// 이제 C모델이 자신과 맞지 않은 기본 구현을 우연찮게 물려받을 가능성은 없어졌다.
// fly함수가 순수 가상 함수라서 스스로 제공하지 않으면 안되는 상황이니

/*
	이런 방법이 실수를 100센트 막을 수는 없다(복사 붙여넣기를 막 하다가 실수할 수 있다.)
	하지만 훨씬 믿고 쓸만해진 것은 틀림없다.

	추가적으로 DefaultFly를 protected로 선언한 것은 Airplane과 그 클래스의 파생 클래스만 내부적으로 사용하는
	구현 세부 사항이기 때문이며, 비행기를 사용하는 사용자는 "비행기는 날 수 있다"라는 점만 알 면 될 뿐이라서..
	그리고 비가상 함수인데 파생 클래스 쪽에서 이 함수를 재정의해선 안 되기 때문이다.

	다른 방법으로 주장되는 것은 순수 가상 함수가 구체 파생 클래스에서 재 선언되어야 한다는 사실을 활용하되,
	자체적으로 순수가상 함수의 구현을 구비해 두는 것
*/

class Airplane3
{
public:
	virtual void fly(const Airport& Destination) = 0;
};

void Airplane3::fly(const Airport& Destination)		//순수 가상함수를 구현
{
	//주어진 목적지로 비행기를 날려보내는 기본 코드
}

class ModelA3 : public Airplane3
{
public:
	virtual void fly(const Airport& Destination)
	{
		Airplane3::fly(Destination);
	}
};

class ModelB3 : public Airplane3
{
public:
	virtual void fly(const Airport& Destination)
	{
		Airplane3::fly(Destination);
	}
};

class ModelC3 : public Airplane3
{
public:
	virtual void fly(const Airport& Destination)
	{
		// 목적지로 modelC 비행기를 날려보내는 코드
	}
};
/*
	별도의 함수인 AirPlane::DefaultFly의 자리에 순수 가상 함수인 Airplane::fly 의 본문이 들어와 있는 것만
	제외하면 이전의 설계와 거의 같다. fly함수가 선언부와 정의부 두 쪽으로 나뉜것.
	선언부는 이 함수의 인터페이스를 지정하고, 정의부는 이 함수의 기본 동작을 지정함. 하지만 fly와
	DefaultFly가 하나로 합쳐지는 발마에 함수 양쪽에 각기 다른 보호 수준을 부여할 수 있는 융통성은 날아가고 말았다.
	protect영역에 있던 코드가 이제 public에 있게 된 것.

	이제 마지막으로 Shape의 비가상 함수 ObjectID를 생각해보자
	멤버 함수가 비가상 함수로 되어 있는 것은, 이 함수는 파생 클래스에서 다른 행동이 일어날 것으로 가정하지 않는다는 것이다.
	실제로 비가상 멤버 함수는 클래스 파생에 상관없이 변하지 않는 동작을 지정하는 데 쓰인다.
	즉 비가상 함수를 선언하는 목적은 파생 클래스가 함수 인터페이스와 더불어 그 함수의 필수적인 구현을 물려받게 하는 것이다.

	비가상함수는 클래스 파생에 상관없는 불변동작과 같기 때문에 파생 클래스에서 재정의 할 수 없다.

	다음으로 멤버 함수를 선언할 때 많이 하는 실수를 보자
	1. 모든 멤버 함수를 비가상 함수로 선언하는 것.
		파생 클래스를 만들더라도 기본 클래스의 동작을 특별하게 만들 만한 여지가 없어짐.
		특히 비가상 소멸자는 문제를 일으킨다.
		가상 함수의 비용과 관련해서는 80:20 법칙을 기억하자.전체 실행 시간의 80%가 소모되는 부분은 전체 코드의20%이다
		가상 함수의 비용을 걱정할 시간에 20%의 코드를 어떻게 짤지 더 고민하자

	2. 모든 멤버 함수를 가상 함수를 선얺는 것.
		분명 파생 클래스에서 재정의가 안되어야 하는 함수도 있을 것이다.
		그럼 이 함수들을 반드시 비가상 함수로 만들어두어 입장을 분명히 밝히자.
		불변동작을 갖고 있어야 한다면 반드시!
*/