/*
	팩토리 함수(새로 생성된 파생 클래스 객체에 대한 기본 클래스 포인터를 반환 하는 함수) 같은 것을 사용할 때가 있는데,
	당연히 그것을 통해 얻은 객체는 힙메모리에 위치하기 때문에, 삭제의 책임이 있다.
	이 때, 기본 클래스 포인터를 통해 해당 객체를 삭제하기 떄문에 기본 클래스의 소멸자가 중요한데,
	만약 기본 클래스의 소멸자가 비가상 소멸자라면 "미정의 동작"을 하게된다. -> 대체로 파생 클래스의 부분이 소멸되지 않는다.
	즉 파생 클래스의 소멸자가 실행되지 않는다. 결국 반쪽짜리 부분 소멸로 남아 자원의 낭비가 생기게 된다.

	이를 해결하는 방법은 그저 기본 클래스의 소멸자를 가상 소멸자로 선언 하는 것이다. virtual 키워드를 붙이면 파생 클래스의 함수를
	실행하게 되는데, 파생 클래스의 소멸자는 기본 클래스의 소멸자를 부르도록 되어 있기 때문에 파생 클래스의 부분, 기본 클래스 부분
	모두 삭제하는 효과를 볼 수 있다.
*/
class TimeKeeper
{
public:
	TimeKeeper();
	virtual ~TimeKeeper();		//소멸자를 가상 소멸자로 선언 이제 TimeKeeper를 상속하는 클래스의 소멸자가 실행되고,
								//해당 파생 클래스의 소멸자가 TimeKeepr 클래스의 소멸자를 실행시킴
};

/*
	어떤 클래스를 사용하게 되든 가상 함수를 하나라도 가진 클래스는 가상 소멸자로 선언하는 습관을 들이자.

	가상 함수를 C++로 구현하게 되면 클래스에 별도의 자료구조가 들어가게 되는데, 이 자료구조는
	vptr(Virtual Table Pointer), 가상함수 테이블 포인터 라고 불린다. 해당 테이블 포인터 는 가상 함수의 주소,
	즉 포인터들의 배열을 가리키고 있으며, 가상함수 하나라도 가지고 있게 된다면 이를 갖게 된다.
	가상 함수를 호출하면 이 포인터가 가리키는 테이블에 따라 함수를 실행 시킨다.

	그렇다면 왜 소멸자는 자동으로 가상 소멸자의 기능을 하게 만들어두지 않으며, 왜 가상 함수를 가질 때만 가상 소멸자를
	선언하라고 하는 것인가?

	만약 어떤 클래스에 가상함수가 들어가게되면, 위에 말했듯 자료구조가 들어가면서 크기가 커지기 때문이다.
	또한 vptr을 구현해야 하는 문제 때문에 다른 언어로의 이식이 힘들어진다.
	vptr과 가상함수로 인한 득과 실에 대한 아래 글을 참고 하자.
	https://dataonair.or.kr/db-tech-reference/d-lounge/technical-data/?mod=document&uid=235880

	추가적으로 string 클래스(STL컨테이너 타입들 모두) 같은 것을 기본 클래스로 만드는 일은 절대 하지말자.
	해당 클래스들은 모두 가상 소멸자가 없기 때문에 미정의 행동에 빠지게 된다.

	상황에 따라서는 순수 가상 소멸자를 다른 목적을 위해 활용할 수도 있다. 바로 추상 클래스로 만들고 싶은데,
	마땅히 마땅히 넣을 순수 가상 함수가 없을 때, 순수 가상 소멸자를 이용해서 해당 클래스를 추상 클래스로 만드는 것이다.
	이를 통해 추상 클래스를 만들고자 하는 목적과 가상 소멸자를 선언해야 한다는 책임 모두를 달성할 수 있다.

*/