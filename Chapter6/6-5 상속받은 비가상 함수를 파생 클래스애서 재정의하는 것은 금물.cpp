/*
	Drived 클래스가 Base클래스를 public상속을 하고, Base 클래스에 mf라는 멤버 함수가 정의되어 있다고 가정하자.
	그리고 다음 코드를 보자
*/

class Base
{
public:
	void mf() {}
};

class Derived : public Base {};

int main()
{
	Derived x;
	Base* pBase = &x;
	pBase->mf();		// Base타입 포인터로 mf 호출

	Derived* pDerived = &x;
	pDerived->mf();		// Derived 타입 포인터로 mf호출
}
/*
	위의 두 mf 호출은 이치적으로는 같은 동작을 해야 한다.
	하지만 그렇지 않을 수 있다는 것이 문제이다.

	만약 Derived 클래스에서 자체적으로 mf함수를 또 정의하고 있다면 Base::mf를 가려 버리기 때문이다.

	이런 동작을 하는 이유는 위 mf가 비가상 함수이기 때문에 "정적 바인딩"을 하기 때문이다.
	pBase는 Base에 대한 포인터 타입이기 때문에 pBase를 통해 호출되는 비가상 함수는 항상 Base에 정의되어 있을 것이라고 결정되기 때문이다.

	반면 가상 함수는 "동적 바인딩"이 이루어지기 때문에 위와 같은 문제가 없다. pBase와 pDerived가 진짜 가리키는 대상은 Derived타입의 객체이기 때문에...
	만약 Base를 상속한 Derived가 Base의 비가상 함수를 재정의해 버리면, Derived 클래스는 일관성이 없는 클래스가 된다. ㅇ
	분명 Derived클래스의 객체인데 Base와 Derived 어디로 튈지 모르게 된다. 심지어 이 것을 결정하는 요인이
	그 객체를 가리키는 포인터의 타입이란 점이 더 암울하게 한다.

	public 상속의 의미는 is-a 이고, 비가상 멤버 함수는 클래스 파생에 관계없느 불변동작을 정해 두는 것이다.
	이 두 가지 개념을 Base, Derived 클래스와 비가상 함수 Base::mf에 대입해 생각해보면
	- Base 객체에 해당하는 모든 것들이 Derived 객체에 그대로 적용된다. 왜냐면 Derived객체는 Base객체의 일종이기 때문에
	- Base에서 파생된 클래스는 mf함수의 인터페이스와 구현을 모두 물려받게 된다. mf는 Base클래스에서 비가상 멤버 함수이기 때문에...

	만약 mf를 Base와 다르게 구현한 것이 진짜로 원해서였고, Base와 Base로부터 파생된 클래스의 객체들이  B의 mf구현을 사용해야 한다고
	정한것이 진짜라며느 mf의 재정의로 인해서 "모든 Derived는 Base의 일종"이라는 명제는 에누리 없이 거짓이 된다.
	이런 상황이라면 Derived는 Base로부터 public 상속을 받으면 안된다.

	한편 Derived는 Base로부터 public상속을 받아 파생시킬 수밖에 없는 사정이 있고, 진짜로 D에서 mf함수를 B의것과
	다르게 구현해야 한다면 "mf는 클래스 파생에 상관없이 Base에 대한 불변동작이다" 라는 점도 참이 되지 않게된다.
	이런 경우라면 mff는 가상 함수로 선언해주는 것이 맞다.
	즉 비가상 함수는 절대 재정의 해서는 안된다.

	이 부분은 소멸자를 가상 소멸자로 선언해야 하는 것과 연결된다.
	다형성 기본 클래스에서 비가상 소멸자로 선언해버리면 파생 클래스에서 여지없이 비가상 소멸자를 재정의 하게되는 것.
	소멸자는 심지어 컴파일러가 자동으로 만들어주기까지 하기 때문에 더욱이 그렇다.
*/